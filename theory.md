## Теоретична частина екзамену

#### Питання 1

**SoC (separations of concerns)** - один з 1000 схожих патернів, що кажуть про розділення логічних частин програми на підпрограми.
Суть SoC - розділення програми на функціональні блоки, не тісно зв'язані між собою. 
Цей паттерн вирішує, а точніше запобігає проблемі дуже тісних зв'язків в коді, які приносять проблеми при зміні однієї логічної частини програми зміною іншої логічної частини коду.
В парадигмах програмування цей патерн по-різному реалізується, в процедурній - розділенням на функції, в ОО - розділенням на об'єкти і методи тощо.
Цей принцип дуже схожий на принцип Low Cohesion i High Coupling.
Приклад з коду елементарний - в додатках з GUI, розділення GUI та іншого програмного коду (інший програмний код не має залежати під наявності GUI)
(використовується в любій лабораторній, де потрібно було реалізувати графічний інтерфейс).

**ISP (interface segreration pripciple)** - один з принципів SOLID, який каже про розділення занадто великих інтерфейсів на менші задля того щоб сутності які використовують цей інтерфейс, не залежали від того, що не використовують.
Ящо базовий клас надає функціональність, яку наслідники не використовують, варто його розділити на пару менших сутностей. 

#### Питання 2

Ці паттерни занадто різні, щоб їх порівнювати, тому просто про них розповім.

**Command** - паттерн, що пропонує створити окрему сутність для взаємодії з іншими сутностями, якщо ця взаємодія складніше чим просто виклик метода або функції.

Приклад з мого коду - Undoable Tree (враппер над деревом, що дає доступ до його методів, зберігаючи минулий стан дерева на кожній зміні і можливість відновити один з станів за допомогою `undo()` i `redo`).
 
 **Strategy** - поведінковий патерн, що відокремлює схожі алгоритми для однієї цілі в окремі класи(функції) з одним класом для виконання(функцією). Тобто для виконання якоїсь дії може використовуватись декілька прикладів.

Приклад з мого коду:

```C++
class NumberInverter {

public:
    enum class Strategy {
         Euclid,
         Fermat
    };
    
    void set_strategy (Strategy s) {
        switch (s) { 
        case Euclid: 
            strategy = std::make_unique<EuclidStrategy>();  
        case Fermat:
         ....
        }

    Number invert(const Number& num) {
        return strategy->invert(num);
    }

private:
    
    std::unique_ptr<InverterStrategy> strategy;
}

class InverterStrategy {
public:
    virtual Number invert();
}

class EuclidStrategy final: public InverterStrategy {
public:
    Number invert() final;
}

class FermatStrategy final: public InverterStrategy {
public:
    Number invert() final;
}
```

Приклад з проекту по модульній довгій арифметиці.

**Prototype** - патерн, що надає можливість створити копію об'кта, не вдаючись в деталі його реалізації.
Це реалізується тим, що створення копії займається сам класс, об'єкт якого копіюють.

Приклад з мого коду:
```
class BinarySearchTree {


    ....
.   ....

    auto operator= (const BinarySearchTree& other) -> BinarySearchTree&
    {
        ... рекурсивне копіювання ноудів дерева other в ноуди *this, з кореня донизу ...
        return *this;
    }
}
```
В С++ глубоке копіювання об'єкту має здійснюватись по дефолту оператором=, на відміну від інших мов, де об'єкт це референс на нього, і копіювання об'єкту виконується поверхнево через оператор=.


#### Class diagram

![Diagram](https://i.imgur.com/XPavi9i.png)
